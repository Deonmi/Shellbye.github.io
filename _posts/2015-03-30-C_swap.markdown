---
author: shellbye
comments: true
date: 2015-03-30 11:27:08+00:00
layout: post
slug: C-swap
title: C swap
categories:
- tech_world
tags:
- C
---

今天在写排序时，需要用到swap函数，自己匆匆写了一个发现没对，于是就想上网找找看，
结果居然打开好几个网页都不对，于是还是不得不自己静下心来认认真真写了一个。
也顺便复习了一下指针。

{% highlight c linenos %}
#include <stdio.h>

void swap(int *a, int *b)
{
     int temp = *a;
     *a = *b;
     *b = temp;
}

int main()
{
    int x=1;
    int y=2;
	swap(&x,&y);
	printf("%d %d", x, y);
	system( "pause" );
}
{% endhighlight %}

首先是调用函数的时候，传入的必须是x和y的地址，如果传入的x和y的值，那么在牛逼的函数也没法交换它们的值，
传值调用是没法修改原始的变量的，就像某人给你签了个名，你不可能通过修改他的签名来修改这个人本身。

传入的是地址的情况下就可以喽，因为这个时候你是准确的知道这个变量在内存的位置的，就像你知道某人的住址，
那么，你就可以带着你的手术刀，去给他做个整容手术，这样他本身就真的变了，别人看到他时，也就看到了你对他的“重塑”。

在来看函数内部，参数列表位置的```int *a, int *b```表明传入的参数是指针，可怕的指针，使用一定要注意。

当函数执行到第5行时，内存里是这个样子的：

![step_1](/assets/step_1.jpg)

其中，x,y,a,b从内存的角度看都是一样的。只是它们中的值有不同的解释方式而已。
此时a和b中存储的值的解释方式就是内存中的地址，于是```*a```的解释方式就是：
“取出a里面的值，把它当做内存中的地址，然后再去该地址所对应的值，这个值用int方式解释”，
就是1，第5行执行之后，内存中是这个样子：

![step_2](/assets/step_2.jpg)

第6行执行完之后，因为```*a = *b;```这句把b中的地址读出来，然后又去读了这个地址，
所以```*b```是2，同理，```*a```这个时候就成了2，所以内存变成下面的样子，

![step_3](/assets/step_3.jpg)
 
第7行执行完之后，内存最终变成了这个样子：

![step_4](/assets/step_4.jpg)
 
当再次回到```main```函数时，x和y的值就这样对调了。